import json
from pathlib import Path

BASE = Path(__file__).resolve().parents[1]
SCHEMAS_SUMMARY = BASE / "schemas_summary.json"
SERVICES_DIR = BASE / "app" / "services"
FAKE_DB_PATH = BASE / "tests" / "fixtures" / "fake_db.py"
FAKE_SERVICES_PATH = BASE / "tests" / "fixtures" / "fake_services.py"

print("ðŸ“¦ GÃ©nÃ©ration des environnements de testâ€¦")

# ---------------------------------------------------------------------------
# 1) CHARGEMENT DES TABLES (schemas_summary.json)
# ---------------------------------------------------------------------------

if not SCHEMAS_SUMMARY.exists():
    raise SystemExit("âŒ schemas_summary.json introuvable.")

with open(SCHEMAS_SUMMARY, "r") as f:
    schemas = json.load(f)

tables = list(schemas.keys())
print(f"ðŸ” Tables dÃ©tectÃ©es : {tables}")


# ---------------------------------------------------------------------------
# 2) GÃ‰NÃ‰RATION DE FAKE_DB
# ---------------------------------------------------------------------------

FAKE_DB_HEADER = """# AUTO-GENERATED FILE
# DO NOT EDIT MANUALLY â€“ generated by generate_fake_test_env.py

from uuid import uuid4
from typing import Dict, Any
from datetime import datetime, date
import uuid as uuid_mod

DB = {
"""

# GÃ©nÃ¨re toutes les tables
db_body = ""
for t in tables:
    db_body += f'    "{t}": [],\n'

db_body += """}

def reset_db():
    for key in DB:
        DB[key] = []

"""

# Normalisation
NORMALIZE = """
def _normalize(x):
    if isinstance(x, uuid_mod.UUID):
        return str(x)
    if isinstance(x, datetime):
        return x.date()
    if isinstance(x, date):
        return x
    if isinstance(x, str) and len(x) == 10 and x.count("-") == 2:
        try:
            return datetime.fromisoformat(x).date()
        except Exception:
            return x
    return x
"""

# Fonctions gÃ©nÃ©riques
CRUD = """
def _find(table: str, filters=None, limit=1000):
    if filters is None:
        filters = {}
    out = []
    for row in DB[table]:
        ok = True
        for k, v in filters.items():
            if v is None:
                continue
            if k in ("order_by", "direction", "limit", "page"):
                continue

            if k.endswith("_lte"):
                base = k[:-4]
                rv = _normalize(row.get(base))
                fv = _normalize(v)
                if rv is None or rv > fv:
                    ok = False
                    break
                continue

            if k.endswith("_gte"):
                base = k[:-4]
                rv = _normalize(row.get(base))
                fv = _normalize(v)
                if rv is None or rv < fv:
                    ok = False
                    break
                continue

            if k.endswith("_neq"):
                base = k[:-4]
                rv = _normalize(row.get(base))
                fv = _normalize(v)
                if rv == fv:
                    ok = False
                    break
                continue

            if k.endswith("_like"):
                base = k[:-5]
                rv = row.get(base)
                if rv is None or str(v).strip("%") not in str(rv):
                    ok = False
                    break
                continue

            if _normalize(row.get(k)) != _normalize(v):
                ok = False
                break

        if ok:
            out.append(row)

    order_by = filters.get("order_by")
    direction = filters.get("direction")

    if order_by:
        out.sort(
            key=lambda r: _normalize(r.get(order_by)),
            reverse=(direction == "desc")
        )

    return out[:limit]


def _insert(table: str, data: Dict[str, Any]):
    DB[table].append(data)
    return data


def _update(table: str, id, payload: Dict[str, Any]):
    for row in DB[table]:
        if row.get("id") == id:
            row.update(payload)
            return row
    return None


def _delete(table: str, id):
    DB[table] = [r for r in DB[table] if r.get("id") != id]
    return {"deleted": True}
"""

# Helpers create_xx()
HELPERS = "\n# --- HELPERS AUTO-GÃ‰NÃ‰RÃ‰S ---\n"
for t in tables:
    func = f"""
def create_{t}(data: Dict[str, Any]):
    if "id" not in data:
        data["id"] = uuid4()
    return _insert("{t}", data)
"""
    HELPERS += func

FAKE_DB_PATH.write_text(FAKE_DB_HEADER + db_body + NORMALIZE + CRUD + HELPERS)
print(f"âœ… fake_db.py gÃ©nÃ©rÃ© â†’ {FAKE_DB_PATH}")


# ---------------------------------------------------------------------------
# 3) GÃ‰NÃ‰RATION DE FAKE_SERVICES
# ---------------------------------------------------------------------------

FAKE_SERVICES_HEADER = """# AUTO-GENERATED FILE
# DO NOT EDIT MANUALLY â€“ generated by generate_fake_test_env.py

from uuid import uuid4
from tests.fixtures.fake_db import DB, _find, _insert, _update, _delete
"""

service_files = [p for p in SERVICES_DIR.glob("*_service.py") if p.stem != "__init__"]

services_code = [FAKE_SERVICES_HEADER]

SERVICE_TEMPLATE = """
class {class_name}:
    def get_all_{table}(self, filters=None, limit=1000, page=1):
        return _find("{table}", filters or {{}}, limit)

    def get_{table}_by_id(self, id):
        return next((r for r in DB["{table}"] if r.get("id") == id), None)

    def create_{table}(self, payload: dict):
        data = dict(payload)
        if "id" not in data:
            data["id"] = uuid4()
        return _insert("{table}", data)

    def update_{table}(self, id, payload: dict):
        return _update("{table}", id, payload)

    def delete_{table}(self, id):
        return _delete("{table}", id)

{instance_name} = {class_name}()
"""

for file in service_files:
    table = file.stem.replace("_service", "")
    class_name = "".join(word.capitalize() for word in table.split("_")) + "Service"
    instance = f"{table}_service"

    services_code.append(
        SERVICE_TEMPLATE.format(
            table=table,
            class_name=class_name,
            instance_name=instance
        )
    )

FAKE_SERVICES_PATH.write_text("\n".join(services_code))
print(f"âœ… fake_services.py gÃ©nÃ©rÃ© â†’ {FAKE_SERVICES_PATH}")

print("\nðŸŽ‰ GÃ©nÃ©ration complÃ¨te terminÃ©e.")
